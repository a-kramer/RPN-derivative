<!DOCTYPE html>
<html lang="en-US">
<!-- SECTION: Symbols in Math Expressions -->
<head>
<title>RPN Derivative</title>
<meta name="keywords" content="Symbols in Math Expressions">
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="generator" content="codedoc v3.7">
<meta name="author" content="Andrei Kramer-Miehe &lt;andrei.kramer@scilifelab.se&gt;">
<meta name="language" content="en-US">
<meta name="copyright" content="© Andrei Kramer-Miehe">
<meta name="version" content="0.0">
<style type="text/css"><!--
body, p, h1, h2, h3, h4, h5, h6 {
    font-family: Fira Sans, sans-serif;
    color: rgb(160,160,160);
    background: rgb(40,40,40);
}

body {
 font-size: 14pt;
}

h1, h2, h3, h4, h5, h6 {
  font-weight: bold;
  page-break-inside: avoid;
}
h1 {
  font-size: 200%;
  margin: 0;
}
h2 {
  font-size: 200%;
  margin-top: 1.5em;
}
h3 {
  font-size: 150%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h4 {
  font-size: 120%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h5 {
  font-size: 110%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
h6 {
  font-size: 105%;
  margin-bottom: 0.5em;
  margin-top: 1.5em;
}
div.header h1, div.header p {
  text-align: center;
}
div.contents, div.body, div.footer {
  page-break-before: always;
}
.class, .enumeration, .function, .struct, .typedef, .union {
  border-bottom: solid 2px gray;
}
.description {
  margin-top: 0.5em;
}
.function {
  margin-bottom: 0;
}
blockquote {
  border: solid thin gray;
  box-shadow: 3px 3px 5px rgba(0,0,0,0.5);
  padding: 0px 10px;
  page-break-inside: avoid;
}
p code, li code, p.code, pre, ul.code li {
  background: rgba(127,127,127,0.1);
  border: thin dotted gray;
  font-family: Fira Code, monospace;
  font-size: 100%;
  hyphens: manual;
  -webkit-hyphens: manual;
  page-break-inside: avoid;
}
p.code, pre, ul.code li {
  padding: 10px;
}
p code, li code {
  padding: 2px 5px;
}
a:link {
  text-decoration: none;
  color: rgb(100,100,240);
}
a:visited {
  color: rgb(200,80,200);
}
span.info {
  background: black;
  border: solid thin black;
  color: white;
  font-size: 80%;
  font-style: italic;
  font-weight: bold;
  white-space: nowrap;
}
h1 span.info, h2 span.info, h3 span.info, h4 span.info {
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  float: right;
  padding: 3px 6px;
}
ul.code, ul.contents, ul.subcontents {
  list-style-type: none;
  margin: 0;
  padding-left: 0;
}
ul.code li {
  margin: 0;
}
ul.contents > li {
  margin-top: 1em;
}
ul.contents li ul.code, ul.contents li ul.subcontents {
  padding-left: 2em;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td {
  border: solid 1px #666;
  padding: 5px 10px;
  vertical-align: top;
}
td.left {
  text-align: left;
}
td.center {
  text-align: center;
}
td.right {
  text-align: right;
}
th {
  border-bottom: solid 2px #000;
  padding: 1px 5px;
  text-align: center;
  vertical-align: bottom;
}
tr:nth-child(odd) {
  background: rgba(127,127,127,0.1);
}
table.list {
  border-collapse: collapse;
  width: 100%;
}
table.list th {
  border-bottom: none;
  border-right: 2px solid gray;
  font-family: monospace;
  padding: 5px 10px 5px 2px;
  text-align: right;
  vertical-align: top;
}
table.list td {
  border: none;
  padding: 5px 2px 5px 10px;
  text-align: left;
  vertical-align: top;
}
h2.title, h3.title {
  border-bottom: solid 2px black;
}
--></style>
</head>
<body>
<div class="header">
<h1 class="title">RPN Derivative</h1>
<p>Andrei Kramer-Miehe &lt;andrei.kramer@scilifelab.se&gt;</p>
<p>© Andrei Kramer-Miehe</p>
</div>
<div class="contents">
<h2 class="title">Contents</h2>
<ul class="contents">
<li><a href="#FUNCTIONS">Functions</a><ul class="subcontents">
<li><a href="#function_name">function_name</a></li>
<li><a href="#is_double">is_double</a></li>
<li><a href="#is_equal">is_equal</a></li>
<li><a href="#is_numeric">is_numeric</a></li>
<li><a href="#symbol_alloc">symbol_alloc</a></li>
<li><a href="#symbol_alloc_op">symbol_alloc_op</a></li>
<li><a href="#symbol_allocd">symbol_allocd</a></li>
<li><a href="#symbol_cmpd">symbol_cmpd</a></li>
<li><a href="#symbol_print">symbol_print</a></li>
</ul></li>
</ul>
</div>
<div class="body">
<h2 class="title"><a id="FUNCTIONS">Functions</a></h2>
<h3 class="function"><a id="function_name">function_name</a></h3>
<p class="description">Given a function enumerator, this return's the function's name</p>
<p class="code">
const char *function_name(enum func f);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>f</th>
<td class="description">one of the known function enum values</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">pointer to the right entry in a global array of strings</p>
<h3 class="function"><a id="is_double">is_double</a></h3>
<p class="description">This function checks whether the symbol is a number and equal to
the given value within double precision rounding errors
<code>(1e-15)+(1e-15)*|y|</code>. So, the equality is approximated.</p>
<p class="code">
int is_double(struct symbol *s, double y);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>s</th>
<td class="description">the symbol to check for approximate equality</td></tr>
<tr><th>y</th>
<td class="description">the value to compare against</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">truth value</p>
<h3 class="function"><a id="is_equal">is_equal</a></h3>
<p class="description">This function tests whether <code>a</code> is equal to <code>b</code>. It uses
<code>memcmp()</code>, so the equality must be exact, but it works regardless
of the symbol's type. Two non-existent symbols are considered
equal, as in: <code>(NULL==NULL)</code>, simlarly <code>is_equal(a,a)</code> is true.</p>
<p class="code">
int is_equal(struct symbol *a, struct symbol *b);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>a</th>
<td class="description">left side of the comparison.</td></tr>
<tr><th>b</th>
<td class="description">right side of the comparison.</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">truth value</p>
<h3 class="function"><a id="is_numeric">is_numeric</a></h3>
<p class="description">This function checks whether the symbol is a number (at all).</p>
<p class="code">
int is_numeric(struct symbol *s);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>s</th>
<td class="description">the symbol to check</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">truth value (the normal kind)</p>
<h3 class="function"><a id="symbol_alloc">symbol_alloc</a></h3>
<p class="description">This is the more flexible allocation function and can create all
kinds of symbols: numbers, variables, operators and functions. The
string <code>s</code> is used to initialize the new symbol struct. Conversion
to a double precision number is attempted, if that fails, the
string is checked against known operator symbols, given only 1 alphabetical 
letter, the string is interpreted as a variable. Lastly it's compared against known functions.</p>
<p class="code">
struct symbol *symbol_alloc(char *s);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>s</th>
<td class="description">a string used to initialize the symbol struct with a type and contents</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">a pointer to the allocated memory for the new symbol</p>
<h3 class="function"><a id="symbol_alloc_op">symbol_alloc_op</a></h3>
<p class="description"></p>
<p class="code">
struct symbol *symbol_alloc_op(char op);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>op</th>
</tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description"></p>
<h3 class="function"><a id="symbol_allocd">symbol_allocd</a></h3>
<p class="description">This function allocates memory for a new symbol and uses the value of <code>d</code> to initialize.</p>
<p class="code">
struct symbol *symbol_allocd(double d);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>d</th>
<td class="description">the value of the new symbol</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">a symbol of type <code>symbol_number</code> with value <code>d</code></p>
<h3 class="function"><a id="symbol_cmpd">symbol_cmpd</a></h3>
<p class="description">This function compares the symbol to <code>y</code> and returns 
<pre>
| case |value|
|------|-----|
|  s&gt;y |  1  |
|  s&lt;y | -1  |
|  s=y |  0  |
|other | -2  |    
```</pre>

If the symbol isn't a number an error code is
returned (not -1, 0, 1).</p>
<p class="code">
int symbol_cmpd(struct symbol *s, double y);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>s</th>
<td class="description">the symbol to check for approximate equality</td></tr>
<tr><th>y</th>
<td class="description">the value to compare against</td></tr>
</tbody></table>
<h4 class="returnvalue">Return Value</h4>
<p class="description">comparison result</p>
<h4 class="discussion">Discussion</h4>
<p class="discussion">If the symbol isn't a number an error code is
returned (not -1, 0, 1).</p>
<h3 class="function"><a id="symbol_print">symbol_print</a></h3>
<p class="description">This function prints a representation of the symbol, as appropriate
for the type.</p>
<p class="code">
void symbol_print(struct symbol *s);</p>
<h4 class="parameters">Parameters</h4>
<table class="list"><tbody>
<tr><th>s</th>
<td class="description">the symbol to print (number, operator, varibale name, or function)</td></tr>
</tbody></table>
</div>
</body>
</html>
